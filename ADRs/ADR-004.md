# ADR-004 — Repository Pattern & State Transition Model

**Status:** Accepted
**Decision Date:** 2025-11-29
**Authors:** Abhishek

## Context

The orchestrator requires a clean separation between:

1. **Domain logic**
   (reservations, executions, scheduling rules)

2. **Persistence implementation**
   (DynamoDB in production, SQLite/memory for dev/tests)

3. **State transitions**
   Execution and reservation states must follow a predictable, validated workflow.

Requirements:

* Decouple business logic from storage backends.
* Allow full mocking for unit tests.
* Make persistence swappable based on environment (local/test/dev/prod).
* Secure and consistent state transitions with optimistic concurrency.
* Clear, auditable lifecycle transitions for:

  * Reservation: `created → active → released/cancelled`
  * Execution: `created → queued → provisioning → running → collecting → completed/failed/cancelled`
  * Tasks: `pending → in_progress → success/failed → retried/DLQ`

This requires a **Repository Pattern** plus a formal, validated **State Transition Model**.

## Options

### Option A — Implement Repository Pattern (Recommended)

Define interfaces like `ReservationRepository`, `ExecutionRepository`, `BenchRepository`, and provide multiple concrete implementations:

* In-memory (tests)
* SQLite (local dev)
* DynamoDB (production)
* Future: Postgres/analytics read-store

### Option B — Direct Persistence Calls in Business Logic

API handlers and services directly use DynamoDB client or ORM.

### Option C — ORM-Like Abstraction Layer

Use a third-party framework to abstract away database details.

## Decision

Adopt **Repository Pattern** + **Explicit State Transition Model**.

All business logic interacts only with interface-based repositories.
State transitions are validated through explicit state machines implemented at the service layer, not embedded ad-hoc in controllers.

## Rationale

* **Testability:** Unit tests can use in-memory repos without touching real DBs.
* **Decoupling:** Storage implementations can evolve independently (e.g., DynamoDB → Postgres → caching layer).
* **Safety:** State transitions become explicit and enforceable, preventing invalid or out-of-order updates.
* **Idempotency:** Repositories can enforce conditional updates and version checks.
* **Debugging:** State machine audit logs simplify issue triage.
* **Multi-backend compatibility:** Required for local dev, CI, and production.

Direct persistence calls (Option B) would tightly couple code to DynamoDB and hinder testing.
ORM abstraction (Option C) is inappropriate because DynamoDB is not relational and requires tailored access patterns.

## Repository Interfaces (Proposed)

Repositories expose predictable CRUD and state transitions:

```
ReservationRepository:
  create(reservation)
  get(reservation_id)
  update_status(reservation_id, old_status, new_status)
  list_by_user(user_id)

ExecutionRepository:
  create(execution)
  get(execution_id)
  update_state(execution_id, version, new_state)
  append_history(execution_id, history_record)

BenchRepository:
  get(bench_id)
  update_state(bench_id, new_state)
  list_by_capability(tag)

TaskRepository:
  enqueue(task)
  get(task_id)
  update_status(task_id, new_status)
  list_pending(limit)
```

All repository methods must include **optimistic concurrency hooks** (e.g., version/timestamp checks).

## State Transition Model

### 1. Reservation State Machine

```
created → active → released
created → cancelled
active → cancelled
```

Rules:

* Only the user or admin can cancel.
* Bench can only be assigned during `active`.

### 2. Execution State Machine

```
created → queued → provisioning → running → collecting → completed
running → failed
queued/provisioning → cancelled
collecting → failed (artifact errors)
```

All transitions must:

* Validate current state
* Emit a state-change event
* Write history to audit store
* Be idempotent (re-apply without side effects)

### 3. Task State Machine

```
pending → in_progress → success
in_progress → failed → pending (retry)
failed (exceeded) → dlq
```

## Pros / Cons

### Pros

* Clean architecture and clear separation of responsibilities
* Easier extensibility (e.g., adding caching later)
* Highly testable
* Enforces safe and predictable state transitions
* Ideal for DynamoDB where conditional writes and versioning matter

### Cons

* More boilerplate versus direct DB calls
* Requires strict documentation and team discipline
* Additional abstraction layer could be misused without code reviews

## Implementation Plan

1. Create repository interfaces under `api/repositories/`.
2. Implement `InMemoryRepository` for all repo types (used in Sprint-1 + Sprint-2 tests).
3. Implement SQLite repository (optional for local dev).
4. Create DynamoDB implementations in Sprint-3.
5. Define `StateTransitionError` and shared validation utilities.
6. Implement explicit state-machine service layer:

   * `ReservationService`
   * `ExecutionService`
   * `TaskService`
7. Require all controllers and workers to use the service layer instead of direct repo calls.
8. Add repository-based unit tests for each permitted state transition.
9. Add integration tests validating concurrency and retry behavior.

## Acceptance Criteria

* Repository interfaces defined and used across API, scheduler, worker.
* In-memory repository fully functional for local dev and unit tests.
* State machine validation implemented for reservation, execution, and task lifecycles.
* Controllers/services no longer perform raw DB operations.
* Documentation updated in `docs/architecture/state-model.md`.

## Consequences

* More structure and boilerplate but significantly improved maintainability.
* Future DB changes (DynamoDB → Postgres → Polyglot) require minimal code changes.
* Easier error triage and operational debugging thanks to explicit transitions.

---

**Summary:**
Implement Repository Pattern with explicit, validated state machines for reservations, executions, and tasks. This ensures testability, clean architecture, and safe concurrency across all orchestrator components.
