# ADR-012 — Authentication & RBAC Model (OIDC + Roles + API Permissions)

**Status:** Accepted
**Decision Date:** 2025-11-29
**Authors:** Abhishek

## Context

The orchestrator exposes sensitive operations:

* Reserving and consuming physical/virtual benches
* Triggering tests that may cost resources (EC2/EKS)
* Reading test artifacts and logs
* Cancelling executions, releasing benches
* Administrative actions (mark bench offline, update metadata)

The system operates in **shared multi-team environments** (CI systems, developers, automation bots), so proper **authentication and authorization** are essential.

Requirements:

* Federated identity (GitHub, Azure AD, Okta, AWS Cognito, etc.)
* Short-lived tokens (to minimize credential leakage)
* Role-based access control (RBAC)
* Minimal friction for CLI and CI pipelines
* Works across cloud, on-prem benches, and hybrid infra
* No long-lived static API keys
* Auditable: all actions tied to user identity
* Does not block local development workflows

## Requirements Summary

1. **Authentication:**

   * Must use OIDC/JWT (industry standard).
   * Token validation must be stateless via JWT signature verification.
   * No session storage required.

2. **Authorization:**

   * RBAC model with 3 core roles:

     * **admin**
     * **operator**
     * **developer**
   * Roles tied to claims in JWT.
   * Enforced on every API endpoint.

3. **Auditability:**

   * Every request logs:

     * `subject (sub)`
     * `correlation_id`
     * `role`
     * `execution_id` (if present)

4. **Security:**

   * No credentials stored in code or logs.
   * Rotation of signing keys handled by IdP.
   * CLI supports local token caching but not storing refresh tokens.

## Options

### Option A — OIDC (Recommended)

* Standard-compliant
* Stateless JWT verification
* Works with multiple IdPs
* Best for hybrid environments
* Easy to use in CLI and CI

### Option B — API Keys

* Simpler, but insecure and non-auditable
* Hard to rotate
* Not suitable for multi-team access

### Option C — OAuth 2.0 with full flows (Auth Code + Refresh Token)

* Powerful but more complex
* Adds refresh token management burden
* Slightly heavy for internal tool

## Decision

Use **OIDC with JWT access tokens**, validated locally by the API service.
Implement **RBAC** using built-in JWT claims or an `roles` array included during token minting.

Role mapping must be **deterministic**:

```
{
  "sub": "abhishek@example.com",
  "roles": ["developer"],
  "exp": 1700000000,
  "iss": "https://issuer.example.com/"
}
```

Authorization logic implemented via decorators/middleware in FastAPI.

## Rationale

### Why OIDC?

* Zero-trust and cloud-native
* No stateful sessions
* No custom crypto logic
* Widely supported across CI systems
* Works for local dev with `--dev-idp` token generator
* Supports short-lived tokens and rotation

### Why RBAC?

* Fine-grained control:

  * Developers can run tests
  * Operators can manage benches
  * Admins can bypass and override states
* Avoids per-user tailoring of permissions
* Simple enough to maintain across sprints

### Why no API Keys?

* Impossible to trace to a specific user
* Security risks if leaked
* Manual rotations
* No built-in expiration

## Roles & Permissions Model

### developer

* Can create/reserve benches
* Can run executions
* Can fetch logs & artifacts
* Cannot mark benches offline
* Cannot override execution state
* Cannot access administrative endpoints

### operator

* All developer permissions
* Can mark a bench offline/online
* Can cancel any execution
* Can view system metrics
* Can run operational diagnostics

### admin

* All operator permissions
* Can force release benches
* Can modify bench metadata
* Can manage users/roles (if needed)
* Can purge DLQ
* Can queue maintenance tasks

## Endpoint Enforcement Examples

| Endpoint                   | developer | operator | admin |
| -------------------------- | --------- | -------- | ----- |
| POST /reservations         | ✓         | ✓        | ✓     |
| POST /executions           | ✓         | ✓        | ✓     |
| DELETE /executions/{id}    | ✗         | ✓        | ✓     |
| POST /benches/{id}/offline | ✗         | ✓        | ✓     |
| POST /admin/purge-dlq      | ✗         | ✗        | ✓     |

Authorization implemented via FastAPI dependency injection or router-level decorators.

## Token Validation Workflow

1. API receives JWT via `Authorization: Bearer <token>`

2. Extracts `iss`, `exp`, `sub`, `roles` claims

3. Validates:

   * Signature (RS256 or ES256 via JWKS)
   * Issuer
   * Expiration

4. Injects identity into request context:

```
request.state.identity = {
  "sub": "...",
  "roles": [...],
  "correlation_id": "...",
  "trace_id": "..."
}
```

5. Authorization middleware checks role → allows/denies.

## CLI Authentication Workflow

* CLI obtains token via:

  * `device flow` (for human users), or
  * OAuth client credentials (for CI bots)

* CLI stores token in:

  ```
  ~/.orchestrator/tokens.json
  ```

* Tokens cached with expiration; refresh by re-running login.

## Audit and Logging Requirements

Every actionable API call must log:

* `subject`
* `roles`
* `execution_id` or `reservation_id`
* `correlation_id`
* `trace_id`
* `action`
* `status`
* `bench_id` (if applicable)

## Implementation Plan

### Sprint 3

* Add FastAPI middleware for OIDC/JWT validation
* Add role enforcement decorators
* Implement CLI login flow stub

### Sprint 4

* Integrate tracing + logging fields (ADR-011) with identity
* Add metrics:

  * unauthorized_requests_total
  * invalid_token_total

### Sprint 5

* Add production IdP integration (GitHub/Azure AD/Okta/Cognito)
* Add CI client credentials
* Add permission tests
* Add audit log dashboards

## Acceptance Criteria

* API enforces authentication on all endpoints
* Permissions correctly applied via RBAC table
* CLI authentication flow works using mock or dev IdP
* All logs include subject and role
* Unauthorized access returns 403 with traceable correlation_id
* Integration tests verify access matrix across roles

## Consequences

* Secure, auditable access control
* Supports both human and CI users
* Overhead: token validation + role checks on every request
* Future support for custom permissions possible without redesign
* Clean role separation simplifies operations and compliance

---

**Summary:**
ADR-012 defines the orchestrator’s security model: **OIDC for authentication**, **JWT for stateless identity**, and **RBAC for authorization** across all API, scheduler, worker, and CLI pathways.
This ensures secure, auditable, scalable access across developers, operators, automation bots, and administrators.
