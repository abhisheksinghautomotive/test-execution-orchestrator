# ADR-001 — Packaging Tool Choice: Poetry vs setuptools

**Status:** Accepted
**Decision Date:** 2025-11-23
**Authors:** Abhishek

## Context

We need a reproducible, maintainable packaging and dependency workflow that will become the template for multiple downstream repos. Requirements:

* Reproducible builds and lockfile support
* Declarative single-file configuration (`pyproject.toml`)
* Good UX for developers (local dev, publish)
* Integration with CI and artifact registries (Artifactory / GitHub Packages)
* Support for dependency groups (dev/test) and build isolation
* Minimal runtime/maintenance burden for a small team / solo maintainer

## Options

1. **Poetry**
2. **setuptools + pip + pip-tools (or pip-tools + virtualenv)**
3. **setuptools with modern PEP 517/518 tooling and optional dependency managers (e.g., hatch, flit)**

## Decision

Adopt **Poetry** as the primary packaging and dependency management tool for this project. Use `pyproject.toml` managed by Poetry and commit `poetry.lock`. Provide clear ADR notes and helper scripts for CI and developers to build using a hermetic build container.

## Rationale

* **Lockfile-first reproducibility:** Poetry produces `poetry.lock` that reliably pins transitive deps; aligns with the reproducible-build requirement.
* **All-in-one UX:** Poetry handles dependency resolution, virtualenv management, packaging (wheel/sdist), and publishing — reducing ad-hoc scripts.
* **pyproject.toml native:** Poetry uses the standardized PEP 621/517 configuration model and avoids legacy setup.py editing.
* **Developer ergonomics:** Simple commands (`poetry install`, `poetry build`, `poetry publish`) reduce onboarding friction for downstream teams.
* **CI friendliness:** Well-supported in CI; can run in a hermetic Docker image with pinned Poetry version.
* **Ecosystem fit:** Easier to integrate dependency groups (dev/test), plugin ecosystem, and semantic-versioning workflows.

## Pros / Cons

### Poetry — Pros

* Lockfile (`poetry.lock`) enforces deterministic installs.
* Single tool for dependency management, build, and publish.
* Good default CLI and readable `pyproject.toml`.
* Built-in versioning helpers (useful for automation).
* Strong community adoption for application and library packaging.

### Poetry — Cons / Mitigations

* Historically stricter dependency solver (can be slower); mitigate by pinning toolchain and using CI caches.
* Some edge cases when publishing to non-default registries; mitigate with explicit `poetry config` and CI secrets for Artifactory.
* Slight divergence from minimalistic setuptools workflows; mitigate via clear CONTRIBUTING docs and helper scripts.

### setuptools + pip-tools — Pros

* Mature, minimal runtime footprint.
* Fine-grained control; widely supported by tooling.

### setuptools + pip-tools — Cons

* Requires multiple tools (`pip-tools`, `twine`) and more scripting to achieve parity with Poetry features.
* Lockfile workflow is more manual; less streamlined for developers.

## Implementation Notes

* Add `pyproject.toml` populated by Poetry and commit `poetry.lock`.
* Pin Poetry version used for local dev and CI by documenting version and using a pinned Docker image for builds.
* Provide wrapper scripts:

  * `scripts/ci-build.sh` — hermetic build using Docker and Poetry (reads lockfile).
  * `scripts/publish-staging.sh` — dry-run publish commands for staging.
* CI: Use a Docker image with Python toolchain + Poetry pinned. Alternatively, install Poetry via official installer in CI with exact version.
* For Artifactory: configure Poetry to use the repository via `poetry config repositories.<name> <url>` and pass credentials via CI secrets or use HTTP token configured in `poetry config http-basic.<name>` in the CI environment only.
* Document local dev commands and CI build commands in `CONTRIBUTING.md` and `RUNBOOK.md`.

## Migration / Interop

* If downstream repos prefer `setuptools`, provide conversion guidance:

  * Use `poetry export -f requirements.txt --dev` to generate requirements for environments that need pip-style installs.
  * Provide build artifacts via `python -m build` in CI if needed.
* Keep ADR record to revisit after 6–12 months or if significant friction appears.

## Consequences

* Enforces a consistent dependency management model across the portfolio.
* Simplifies CI configuration and reproducible build guarantees.
* Slight learning curve for contributors unfamiliar with Poetry mitigated by documentation and helper scripts.

---

**Summary:** Use Poetry with pinned toolchain and committed `poetry.lock` to meet reproducible builds, developer ergonomics, and CI integration requirements.
