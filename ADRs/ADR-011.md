# ADR-011 — Logging Format & Tracing Propagation Standard

**Status:** Accepted
**Decision Date:** 2025-11-29
**Authors:** Abhishek

## Context

The orchestrator is a **distributed system** composed of:

* API service
* Scheduler
* Worker pool
* Runner adapters (EC2/EKS/On-Prem)
* Queue layer (SQS or in-memory)

A single execution spans multiple components.
Debugging failure scenarios requires linking logs, metrics, and traces across the full lifecycle.

To achieve observability goals from ADR-010, we need **standardized logging fields**, **correlation IDs**, and **trace propagation rules** that work everywhere:

* Local dev
* CI
* Dev/Staging environments
* Production
* Cloud runners
* On-prem benches

This ADR defines the **canonical logging format** and **how correlation/trace IDs propagate** through the orchestrator workflow.

## Requirements

### Logging Requirements

* All logs must be **structured JSON**
* All logs must include the same core identifiers
* Log format must be stable and machine-parseable
* Must be compatible with Loki, CloudWatch, and Splunk
* Must be human-readable when pretty-printed
* Must support easy grepping/filtering during troubleshooting

### Tracing Requirements

* Use **W3C Trace Context** headers (`traceparent`, `tracestate`)
* All components must propagate OpenTelemetry trace IDs
* Trace IDs must map to execution IDs where appropriate
* Tracing must survive queue boundaries and async operations
* Every worker, runner, and adapter must start child spans

### Cross-cutting Requirements

* Correlation IDs must stay constant per API request
* Execution IDs must appear in all logs for that execution
* Must not leak secrets or PII in logs
* Must support on-prem + cloud hybrid setup

## Options

### Option A — JSON logs + W3C Trace Context + internal correlation ID (Recommended)

Centralized, consistent, modern, and compatible with OTEL.

### Option B — Free-form logs + regex parsing

Unreliable and unscalable.

### Option C — Vendor-specific formats (CloudWatch structured fields)

Not portable enough for hybrid deployments.

## Decision

Adopt **Option A**:

* **Structured JSON logs**
* **W3C Trace Context propagation**
* **Correlation ID (UUIDv4)** per inbound request
* **Execution ID (ULID)** included when applicable
* **Task ID (UUIDv4)** included for worker operations

## Rationale

### Why JSON structured logs?

* Machine-friendly + human-readable
* Works with Loki, Elk, CloudWatch, Datadog
* Eliminates parsing ambiguity
* Easy for automated log analytics tools

### Why W3C Trace Context?

* Industry standard
* Required by OpenTelemetry
* Works across HTTP, gRPC, queues, async calls
* Avoids vendor lock-in

### Why maintain correlation_id separate from trace_id?

* Correlation ID = stable per request
* Trace ID = may span many components
* Separation improves debugging and isolates tracing from business logic

## Standard Logging Fields

Every log line **must** contain:

```
{
  "timestamp": "<RFC3339>",
  "level": "INFO|WARN|ERROR|DEBUG",
  "message": "<log message>",
  "component": "api|scheduler|worker|adapter|queue|infra",
  "module": "<python module name>",
  "function": "<function name>",
  "thread": "<thread or async task id>",

  "correlation_id": "<UUIDv4>",
  "trace_id": "<W3C trace id>",
  "span_id": "<span id>",
  "execution_id": "<ULID or null>",
  "reservation_id": "<ULID or null>",
  "task_id": "<UUIDv4 or null>",

  "context": { ... }   // Arbitrary structured metadata
}
```

### Required rules

* `correlation_id` is always present
* `execution_id` appears only when relevant
* `trace_id` & `span_id` always populated if OpenTelemetry is enabled
* Sensitive data never included

## Trace Propagation Rules

### API → Scheduler

* When execution is created:

  * API generates execution_id (ULID)
  * trace_id flows from request headers or new OTEL trace

### Scheduler → Queue

* Task envelope includes:

  * trace_id
  * correlation_id
  * execution_id

Workers restore trace context from the envelope.

### Queue → Worker

* Worker starts a new span if trace cannot be restored
* Worker extends trace for provision/run/collect/teardown steps

### Worker → Runner Adapter

* Runner adapter inherits current span
* Sub-spans created for:

  * provision()
  * run_test()
  * collect_artifacts()
  * teardown()

### Runner → AWS / Bench Systems

* trace_id propagated where supported (e.g., AWS SDK OTEL instrumentation)
* If external systems do not support tracing, logs include trace_id manually

## Log Severity Conventions

* `INFO`: normal execution steps
* `WARN`: retries, slow tasks, degraded benches
* `ERROR`: runner failures, task failures, provisioning error
* `DEBUG`: verbose details, disabled in prod
* `CRITICAL`: unrecoverable system errors (alerts triggered)

## Example Log Line

```
{
  "timestamp": "2025-11-29T14:52:33.123Z",
  "level": "INFO",
  "message": "Runner execution completed",
  "component": "worker",
  "module": "workers.executor",
  "function": "execute_task",
  "thread": "task-17",

  "correlation_id": "b9f83b3f-64c7-45c1-aada-cd25a2bdcf81",
  "trace_id": "4bf92f3577b34da6a3ce929d0e0e4736",
  "span_id": "00f067aa0ba902b7",
  "execution_id": "01JH2Y9TSZ4Z4XK6HZEK2FJC8P",
  "task_id": "57e0d84e-8e11-4c95-8852-893e0f6a91bd",

  "context": {
    "runner_type": "ec2",
    "status": "success",
    "duration_ms": 8123
  }
}
```

## Implementation Plan

### Sprint 2 (partial)

* Introduce `correlation_id` middleware in API
* Add initial structured logger shared by all components
* Ensure tasks carry correlation_id + execution_id

### Sprint 3

* Add trace propagation to queue envelope
* Implement structured logs in worker, scheduler, adapters

### Sprint 4

* Integrate OpenTelemetry auto-instrumentation
* Full tracing from API → Runner
* Emit metrics linked with trace_id
* Add logging dashboards in Grafana
* Add log labels for environment, version, sprint

### Sprint 5

* Add log retention & security rules
* Add PII-scan to CI
* Add log schema validation tests

## Acceptance Criteria

* All logs follow JSON schema
* Every log contains correlation_id
* Traces propagate correctly across queue boundaries
* Workers reconstruct trace context from task envelope
* API includes correlation_id in HTTP response headers
* Loki/Grafana can query logs by execution_id or correlation_id
* Trace linking between API → worker → runner visible in Tempo/Jaeger

## Consequences

* Greatly simplifies debugging distributed failures
* Requires discipline: all components must use the standard logger
* Slight performance overhead from JSON logging + tracing
* Enables forensic-level root-cause investigations
* Ensures compliance and consistent audit logging

---

**Summary:**
ADR-011 standardizes **structured JSON logging** and **end-to-end W3C trace propagation** across all orchestrator components.
This ensures reliable debugging, observability, and consistent traceability across API, scheduler, workers, and runners.
