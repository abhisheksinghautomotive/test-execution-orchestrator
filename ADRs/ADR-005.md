# ADR-005 — Execution ID Format & Correlation/Trace ID Model

**Status:** Accepted
**Decision Date:** 2025-11-29
**Authors:** Abhishek

## Context

The orchestrator must support:

* End-to-end traceability across API → Scheduler → Queue → Worker → Runner → Artifact Store
* A consistent identifier format for:

  * Execution IDs
  * Reservation IDs
  * Task IDs
  * Correlation IDs (per request)
  * Trace IDs (per execution or workflow)
* Compatibility with:

  * OpenTelemetry tracing in Sprint 4
  * Distributed logging (Loki/CloudWatch)
  * S3 artifact paths
  * DynamoDB partition keys (string type)
* Guaranteed global uniqueness
* Short and URL-safe identifiers for CLI, logs, dashboards, and JIRA links

The ID models must be deterministic, decodable where useful, storage-friendly, and not tied to any specific database.

## Requirements

* Unique across the entire system (cluster-wide)
* Works in multi-region or hybrid deployment scenarios
* Works in DynamoDB partition keys and S3 prefix paths
* Should not expose sensitive information
* Must be easy to search in logs and dashboards
* Compliant with OpenTelemetry’s trace/span ID recommendations
* Compatibility with UUID4 or ULID
* Collisions must be cryptographically improbable
* CLI-friendly and short enough for human debugging

## Options

### Option A — UUIDv4 for all IDs + separate correlation ID

(Strong randomness, widely supported)

### Option B — ULID (Universally Unique Lexicographically Sortable ID)

(Time-sortable, URL-safe, easier debugging)

### Option C — Custom Base32/KSUID-style IDs

(Time encoded + randomness)

### Option D — Use OpenTelemetry’s built-in trace IDs as execution IDs

(Not ideal; trace=execution coupling breaks boundaries)

## Decision

Use the following unified identifier model:

* **Execution IDs** → **ULID**
* **Reservation IDs** → **ULID**
* **Task IDs** → **UUIDv4** (workers generate tasks, no sorting required)
* **Correlation IDs** → **UUIDv4** (fresh per API request)
* **Trace IDs** → OpenTelemetry Trace ID (separate from execution ID)

This provides the best combination of:

* Human readability
* Time ordering (for dashboards & logs)
* Strong randomness
* Compatibility with distributed tracing
* Safe for S3, DynamoDB, URLs, CLI, logs

## Rationale

### Why ULID for Execution and Reservation IDs

* ULIDs are lexicographically sortable → clean time-ordered views in DynamoDB & S3
* Shorter and more readable than UUIDv4
* URL-safe and case-insensitive
* Ideal for debugging execution timelines
* Enables natural chronological ordering of runs without a secondary index

### Why UUIDv4 for Correlation IDs and Task IDs

* Correlation ID should not encode time → always random
* Each request gets its own correlation ID → good for log scoping
* Tasks often do not require sortability (scheduler orders them)
* UUIDv4 avoids accidental coupling with execution semantics

### Why not use trace IDs as execution IDs

* Execution lifecycle may span multiple traces
* Trace IDs are tied to instrumentation, not business identity
* Execution ID must be stable even if tracing system is swapped or disabled

## Identifier Structure

### ULID Example

```
01JH2Y9TSZ4Z4XK6HZEK2FJC8P
```

Properties:

* 26 characters
* Base32 Crockford encoding
* Monotonic sorting
* Perfect for logs, S3 prefixes, dashboards

### UUIDv4 Example

```
84b3dcba-795c-4e8e-905e-badf50d989c4
```

Properties:

* Full randomness
* Well-supported across all tracing and logging tools

## Implementation Guidelines

### Execution ID

Generated at execution creation time in the API service:

```
execution_id = ulid.new()
```

### Reservation ID

Generated at reservation creation time.

### Task ID

Generated by scheduler/worker:

```
task_id = uuid4()
```

### Correlation ID

Injected per API request (middleware layer):

```
X-Correlation-ID: <uuid4>
```

Also logged in workers and scheduler logs.

### Trace ID

Handled by OpenTelemetry instrumentation; automatically propagates via:

* HTTP headers (W3C Trace Context)
* Worker → API → Runner boundaries

### Logging Requirements

Every log line must include:

* `correlation_id`
* `execution_id` (if available)
* `task_id` (for worker logs)
* `trace_id` (auto-injected by OTEL)

### Storage Requirements

DynamoDB partition keys use ULIDs as strings.
GSIs may index execution_id, reservation_id, or trace relationships.

### Artifact Storage Requirements

S3 path example:

```
s3://orchestrator-artifacts/<execution_id>/<task_id>/logs.txt
```

## Acceptance Criteria

* ULID generator included in utility package.
* Middleware adds `X-Correlation-ID` for every API request.
* Every log entry includes correlation_id.
* Repository layer uses ULIDs as PKs.
* Execution ID appears consistently in S3 paths, logs, and DB items.
* Tracing headers passed across API → scheduler → worker → runner.

## Consequences

* ULIDs make chronological debugging easier.
* Developers can grep logs by ID easily.
* OpenTelemetry trace IDs stay purely observability-focused.
* Slight learning curve for ULIDs but negligible with documentation.
* Aligns with cloud-native best practices for distributed systems.

---

**Summary:**
Use **ULID for execution and reservation IDs**, **UUIDv4 for correlation and task IDs**, and rely on **OpenTelemetry trace IDs** for distributed tracing. This ensures global uniqueness, traceability, sortability, and compatibility across all system components.
